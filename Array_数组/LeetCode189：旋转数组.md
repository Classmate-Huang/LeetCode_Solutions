# LeetCode189：旋转数组

## 题目
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

> 输入: [1,2,3,4,5,6,7] 和 k = 3
> 输出: [5,6,7,1,2,3,4]
> 解释:
> 向右旋转 1 步: [7,1,2,3,4,5,6]
> 向右旋转 2 步: [6,7,1,2,3,4,5]
> 向右旋转 3 步: [5,6,7,1,2,3,4]

示例 2:

> 输入: [-1,-100,3,99] 和 k = 2
> 输出: [3,99,-1,-100]
> 解释: 
> 向右旋转 1 步: [99,-1,-100,3]
> 向右旋转 2 步: [3,99,-1,-100]

说明:

> 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
> 要求使用空间复杂度为 O(1) 的 原地 算法。

## 解法一
最简单的解法，用`nums[(i+k)%n]=nums[i]`(n为数组长度)将数组所有位置上的元素都这样处理一遍即可。但是这个题目要求使用空间复杂度为O(1)的‘原地’算法，这给我们的处理带了一些麻烦。
**处理难点：**
①首先，不能使用额外的数组，就需要将每次移动的元素保存下来，比如`[0,1,2,3,4,5]，k=2`，要把0放在2的位置上，如果只是单纯的nums[(i+2)%3]=nums[i],那么'2'就会遗失。**所以需要将每次移除的值保存下来。**
②其次，如果只是单纯地循环，从i=0循环到i=5，那么需要保存的值就会很多。`[0,1,2,3,4,5]，k=2`，0->2,就要保存2,1->3,又要保存3... 如此处理下来，会很麻烦。**所以要利用模拟的思想，比如0->2之后，我们就需要为2安排放置的位置，2->4... 这样只需要保存当前移除的值既可。**
③最后，要考虑一种情况，`[0,1,2,3,4,5]，k=2`按照模拟的思想，`0->2,2->4,4->0`这样模拟下来，会剩下一些元素没有被处理（1,3,5）。有两种方法来解决这个问题，一是**用一个值来保存目前移动的次数，次数要等于数组的长度才结束(当次数不能增加是，i=i+1)**，二是**利用欧几里得算法(gcd)计算出n和k的最大公因数cnt，然后需要循环cnt * (n/cnt)次。**
==说明：==
还是`[0,1,2,3,4,5]，k=2`，现在n=6，k=2，最大公因数cnt=2。所以一次模拟只能处理1/2的数组元素，第一次`0->2, 2->4, 4->0`，第二次`1->3, 3->5, 5->1`。

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size(), cnt, t, pre, next;
        cnt = gcd(n, k);
        for(int i=0; i<cnt; i++){
            t = n/cnt;
            int index = i;
            pre = nums[index];
            while(t--){
                next = nums[(index+k)%n];
                nums[(index+k)%n] = pre;
                pre = next;
                index = (index+k)%n;
            }
        }
    }
    int gcd(int x,int y){		// gcd算法
        return x==0?y:gcd(y%x, x);
    }
};
```
时间复杂度：O(n)，n为数组长度。
空间复杂度：O(1)。

==说明：==
这个程序中，使用pre保存目前移动的元素，next用来保存被替代的元素(也就是下一个要移动的元素)。参考了题解下面一个解释，我觉得很助于理解思路：可以想象现在有一排位置（nums数组），每个位置上坐了对应的同学，现在要交换位置，每个同学向右移动k个位置。**每次需要记住被移动同学的名字，只给现在离开座位的同学安排位置。** 找位置的同学就是`pre`，被代替的同学就是`next`。

## 解法二
三个`reverse()`解决问题

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        k = k%n;
        reverse(nums.begin(), nums.begin()+n);
        reverse(nums.begin(), nums.begin()+k);
        reverse(nums.begin()+k, nums.begin()+n);
    }
};
```
时间复杂度：O(N)，N为数组长度，其中每个元素需要被reverse两次。
空间复杂度：O(1)。

==说明：==
直接举一个例子即可说明问题，`[0,1,2,3,4,5]，k=2`。

1. 第一次reverse-翻转所有数组元素:`[5,4,3,2,1,0]`
2. 第二次reverse-翻转前k个数组元素：`[4,5,3,2,1,0]`
3. 第三次reverse-翻转后n-k个数组元素：`[5,4,0,1,2,3]`