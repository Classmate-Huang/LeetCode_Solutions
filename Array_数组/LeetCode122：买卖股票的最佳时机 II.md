# LeetCode122：买卖股票的最佳时机 II

## 题目

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4，随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 

示例 2:

> 输入: [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:

> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

> 1 <= prices.length <= 3 * 10 ^ 4
> 0 <= prices[i] <= 10 ^ 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解法一

使用`模拟`的思想，我们总是期望在一个上涨周期内最低点买入，最高点卖出，所以对数组进行一次遍历，记录上涨周期的最低点与最高点，然后求和即可，代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int s, e, n=prices.size(), m;
        s=e=m=0; 	// s和e均指向一个周期内的最低点和最高点
        while(e<n){
            if(e+1==n){
                m += prices[e]-prices[s];
                break;
            }
            if(prices[e+1]<prices[e]){   // 该上涨周期已结束
                m += prices[e]-prices[s];
                s=e+1;
                e++;
            }
            else e++;
        }
        return m;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)

## 解法二

解法二就比较巧妙了，对于一个上涨周期(eg. `[1,2,3,4,5]`)，解法一的做法是找到1和5，然后5-1=4；对于解法二，我们可以这样操作，只要后一个元素比当前元素要大，证明还处于上涨周期内，那么就可以先计算它们之间的差值，依次计算下去可以得到相同的结果：`2-1` + `3-2` + `4-3` + `5-4` = 4，代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int m=0;
        for(int i=0; i<prices.size()-1; i++){
            if(prices[i+1]>prices[i])
                m += prices[i+1]-prices[i];
        }
        return m;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)